/**
  * Generated by smali2java 1.0.0.558
  * Copyright (C) 2013 Hensence.com
  */

package net.openvpn.openvpn;

import java.security.PrivateKey;
import android.util.Log;
import android.os.Build;
import java.lang.reflect.Method;
import java.security.InvalidKeyException;
import android.content.Context;
import android.security.KeyChain;

public class JellyBeanHack extends JellyBeanHackBase {
    private static final String TAG = "JellyBeanHack";
    private String alias_;
    private PrivateKey pk_;
    private boolean rsa_sign_initialized;
    
    private static native void pkey_retain(int p1);
    
    
    private static native int rsa_sign_init();
    
    
    public static JellyBeanHack newJellyBeanHack() {
        Log.i("JellyBeanHack", String.format("Build.VERSION.SDK_INT=%d", Build.VERSION.SDK_INT));
        if(Build.VERSION.SDK_INT == 0x10) {
            return new JellyBeanHack();
        }
        return null;
    }
    
    private JellyBeanHack() {
        rsa_sign_initialized = false;
        resetPrivateKey();
        if(rsa_sign_init() == 0x1) {
            rsa_sign_initialized = true;
        }
        Log.i("JellyBeanHack", String.format("JellyBeanHack: rsa_sign_initialized=%b", Boolean.valueOf(rsa_sign_initialized)));
    }
    
    public boolean enabled() {
        return rsa_sign_initialized;
    }
    
    public synchronized void resetPrivateKey() {
        Log.i("JellyBeanHack", "JellyBeanHack: resetPrivateKey");
        alias_ = 0x0;
        pk_ = 0x0;
    }
    
    public synchronized PrivateKey getPrivateKey(Context context, String alias) throws Exception {
        PrivateKey pk = get_pk(alias);
        if(pk == null) {
            pk = set_pk(alias, KeyChain.getPrivateKey(context, alias));
        }
        return pk;
    }
    
    public synchronized byte[] rsaSign(PrivateKey pk, byte[] data) throws Exception {
        return rsa_sign(data, openssl_pkey(pk));
    }
    
    private synchronized PrivateKey get_pk(String alias) {
        if((alias_ == null) || (!alias_.equals(alias))) {
            alias_.equals(alias) = false;
            boolean localboolean1 = pk_;
            return alias_.equals(alias);
        }
        // Parsing error may occure here :(
    }
    
    private synchronized PrivateKey set_pk(String alias, PrivateKey pk) throws Exception {
        alias_ = 0x0;
        pk_ = 0x0;
        if(pk != null) {
            pkey_retain(openssl_pkey(pk));
            if((alias != null) && (alias.length() > 0)) {
                alias_ = alias;
                pk_ = pk;
            }
        }
        return pk_;
    }
    
    private static int openssl_pkey(PrivateKey privkey) throws Exception {
        if(privkey != null) {
            Method getKey = getClass().getSuperclass().getDeclaredMethod("getOpenSSLKey", new Class[0x0]);
            getKey.setAccessible(true);
            Object opensslkey = getKey.invoke(privkey, new Object[0x0]);
            getKey.setAccessible(false);
            Method getPkeyContext = opensslkey.getClass().getDeclaredMethod("getPkeyContext", new Class[0x0]);
            getPkeyContext.setAccessible(true);
            int pkey = (Integer)getPkeyContext.invoke(opensslkey, new Object[0x0]).intValue();
            getPkeyContext.setAccessible(false);
            return pkey;
        }
        return 0x0;
    }
}
