/**
 * Generated by smali2java 1.0.0.558
 * Copyright (C) 2013 Hensence.com
 */

package wuxian.com.liu;

import android.content.BroadcastReceiver;
import android.os.SystemClock;
import android.content.Context;
import android.content.Intent;
import android.util.Log;
import android.app.PendingIntent;
import android.os.Binder;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.net.URLEncoder;
import java.util.Comparator;
import java.io.IOException;

import android.content.res.Resources;
import android.content.res.AssetManager;

import java.util.Collections;
import java.util.Iterator;

import android.net.VpnService;
import android.os.ParcelFileDescriptor;
import android.os.Handler;

import java.util.ArrayDeque;
import java.text.SimpleDateFormat;
import java.util.HashMap;

import android.os.IBinder;
import android.app.Notification;

import java.security.cert.X509Certificate;
import java.security.cert.CertificateEncodingException;

import android.util.Base64;
import android.os.Message;

import java.util.Date;

import android.content.IntentFilter;

import java.io.File;

import android.os.Build;
import android.security.KeyChain;

import java.security.PrivateKey;

import javax.crypto.Cipher;

import java.security.Key;

import android.preference.PreferenceManager;
import android.content.SharedPreferences;

public class OpenVPNService extends VpnService implements OpenVPNClientThread.EventReceiver, Handler.Callback {
    public static final String ACTION_BASE = "net.openvpn.openvpn.";
    public static final String ACTION_BIND = "net.openvpn.openvpn.BIND";
    public static final String ACTION_CONNECT = "net.openvpn.openvpn.CONNECT";
    public static final String ACTION_DELETE_PROFILE = "net.openvpn.openvpn.DELETE_PROFILE";
    public static final String ACTION_DISCONNECT = "net.openvpn.openvpn.DISCONNECT";
    public static final String ACTION_IMPORT_PROFILE = "net.openvpn.openvpn.IMPORT_PROFILE";
    public static final String ACTION_IMPORT_PROFILE_VIA_PATH = "net.openvpn.openvpn.ACTION_IMPORT_PROFILE_VIA_PATH";
    public static final String ACTION_RENAME_PROFILE = "net.openvpn.openvpn.RENAME_PROFILE";
    public static final String ACTION_SUBMIT_PROXY_CREDS = "net.openvpn.openvpn.ACTION_SUBMIT_PROXY_CREDS";
    public static final int EV_PRIO_HIGH = 0x3;
    public static final int EV_PRIO_INVISIBLE = 0x0;
    public static final int EV_PRIO_LOW = 0x1;
    public static final int EV_PRIO_MED = 0x2;
    private static final int GCI_REQ_ESTABLISH = 0x0;
    private static final int GCI_REQ_NOTIFICATION = 0x1;
    public static final String INTENT_PREFIX = "net.openvpn.openvpn";
    private static final int MSG_EVENT = 0x1;
    private static final int MSG_LOG = 0x2;
    private static final int NOTIFICATION_ID = 0x66a;
    private static final String TAG = "OpenVPNService";
    private boolean active;
    private ArrayDeque<OpenVPNService.EventReceiver> clients;
    private CPUUsage cpu_usage;
    private OpenVPNService.Profile current_profile;
    private final SimpleDateFormat dateFormat;
    private boolean enable_notifications;
    private HashMap event_info;
    private JellyBeanHack jellyBeanHack;
    private OpenVPNService.EventMsg last_event;
    private OpenVPNService.EventMsg last_event_prof_manage;
    private ArrayDeque<OpenVPNService.LogMsg> log_deque;
    public static final int log_deque_max = 0xfa;
    private final IBinder mBinder;
    private OpenVPNService.ConnectivityReceiver mConnectivityReceiver;
    private Handler mHandler;
    Notification.Builder mNotifyBuilder;
    private OpenVPNClientThread mThread;
    private PrefUtil prefs;
    private OpenVPNService.ProfileList profile_list;
    public ProxyList proxy_list;
    private PasswordUtil pwds;
    private boolean shutdown_pending;
    private long thread_started;

    public OpenVPNService() {
        dateFormat = new SimpleDateFormat("HH:mm:ss.SSS");
        clients = new ArrayDeque();
        active = false;
        shutdown_pending = false;
        thread_started = 0x0;
        log_deque = new ArrayDeque();
        mBinder = new OpenVPNService.LocalBinder(this);
    }

    static {
        System.loadLibrary("ovpncli");
        ClientAPI_OpenVPNClient.init_process();
        String test = ClientAPI_OpenVPNClient.crypto_self_test();
        Log.d("OpenVPNService", test);
    }

    class EventInfo {
        public int flags;
        public int icon_res_id;
        public int priority;
        public int progress;
        public int res_id;

        public EventInfo(int res_id_arg, int icon_res_id_arg, int progress_arg, int priority_arg, int flags_arg) {
            res_id = res_id_arg;
            icon_res_id = icon_res_id_arg;
            progress = progress_arg;
            priority = priority_arg;
            flags = flags_arg;
        }
    }

    public ArrayDeque log_history() {
        return log_deque;
    }

    class ProxyContext {
        private boolean allow_creds_dialog;
        private Intent connect_intent;
        private long expires;
        private boolean explicit_creds;
        private int n_retries;
        private String profile_name;
        private ProxyList.Item proxy;
        private String proxy_password;
        private String proxy_username;

        public void new_connection(Intent connect_intent, String profile_name, String proxy_name, String username, String password, boolean allow_creds_dialog, ProxyList proxy_list, boolean proxy_retry) {
            if (!proxy_retry) {
                ProxyList.Item p = proxy_list.get(proxy_name);
                if (p != null) {
                    proxy = p;
                    profile_name = profile_name;
                    connect_intent = connect_intent;
                    allow_creds_dialog = allow_creds_dialog;
                    n_retries = 0x0;
                    expires = (SystemClock.elapsedRealtime() + 0x1d4c0);
                    if (!explicit_creds) {
                        if ((username != null) && (password != null)) {
                            proxy_username = username;
                            proxy_password = password;
                            return;
                        }
                        proxy_username = p.username;
                        proxy_password = p.password;
                    }
                    return;
                }
                reset();
            }
        }

        public Intent submit_proxy_creds(String proxy_name, String username, String password, boolean remember_creds, ProxyList proxy_list) {
            if ((proxy != null) && (proxy.name().equals(proxy_name)) && (username != null) && (password != null)) {
                proxy_username = username;
                proxy_password = password;
                explicit_creds = true;
                if (remember_creds) {
                    proxy.username = username;
                    proxy.password = password;
                    proxy.remember_creds = remember_creds;
                    proxy_list.put(proxy);
                    proxy_list.save();
                }
                n_retries = (n_retries + 0x1);
                return connect_intent;
            }
            return null;
        }

        public void client_api_config(ClientAPI_Config config) {
            if (proxy != null) {
                config.setProxyHost(proxy.host);
                config.setProxyPort(proxy.port);
                if ((proxy_username != null) && (proxy_password != null)) {
                    config.setProxyUsername(proxy_username);
                    config.setProxyPassword(proxy_password);
                }
                config.setProxyAllowCleartextAuth(proxy.allow_cleartext_auth);
            }
        }

        public boolean should_launch_creds_dialog() {
            return ((proxy != null) && (allow_creds_dialog));
        }

        public void configure_creds_dialog_intent(Intent intent) {
            if ((proxy != null) && (profile_name != null)) {
                intent.putExtra("net.openvpn.openvpn.PROFILE", profile_name);
                intent.putExtra("net.openvpn.openvpn.PROXY_NAME", proxy.name());
                intent.putExtra("net.openvpn.openvpn.N_RETRIES", n_retries);
                intent.putExtra("net.openvpn.openvpn.EXPIRES", expires);
            }
        }

        public void invalidate_proxy_creds(ProxyList proxy_list) {
            if (proxy != null) {
                if (proxy.invalidate_creds()) {
                    proxy_list.put(proxy);
                    proxy_list.save();
                }
            }
            proxy_username = 0x0;
            proxy_password = 0x0;
        }

        public String name() {
            if (proxy != null) {
                return proxy.name();
            }
            return null;
        }

        public boolean is_expired() {
            boolean localboolean1 = expires != 0x0;
            if (SystemClock.elapsedRealtime() > expires) {
                return true;
            }
            return localboolean1;
        }

        private void reset() {
            profile_name = 0x0;
            proxy = 0x0;
            connect_intent = 0x0;
            expires = 0x0;
            explicit_creds = false;
            proxy_username = 0x0;
            proxy_password = 0x0;
            allow_creds_dialog = false;
            n_retries = 0x0;
        }
    }

    class DynamicChallenge {
        public OpenVPNService.Challenge challenge;
        public String cookie;
        public long expires;

        private DynamicChallenge() {
            challenge = new OpenVPNService.Challenge();
        }

        public boolean is_expired() {
            return (SystemClock.elapsedRealtime() > expires);
        }

        public long expire_delay() {
            return (expires - SystemClock.elapsedRealtime());
        }

        public String toString() {
            return String.format("%s/%s/%s", challenge.toString(), cookie, expires);
        }
    }

    class ProfileFN {

        public static boolean has_ovpn_ext(String fn) {
            if (fn != null) {
                boolean localboolean1 = (!endsWith(".ovpn")) && (endsWith(".OVPN"));
                return true;
            }
            return false;
        }

        public static String strip_ovpn_ext(String fn) {
            if ((fn != null) && (has_ovpn_ext(fn))) {
                fn = substring(0x0, (length() - 0x5));
            }
            return fn;
        }

        public static String encode_profile_fn(String name) {
            try {
                return URLEncoder.encode(name, "UTF-8") + ".ovpn";
            } catch (UnsupportedEncodingException e) {
                Log.e("OpenVPNService", "UnsupportedEncodingException when encoding profile filename", e);
            }
            return null;
        }
    }

    class CustomComparator implements Comparator {

        public int compare(OpenVPNService.Profile p1, OpenVPNService.Profile p2) {
            return OpenVPNService.Profile.name.compareTo(OpenVPNService.Profile.name);
        }
    }

    private void sort() {
        Collections.sort(this, new OpenVPNService.ProfileList.CustomComparator(this, 0x0));
    }
}

class CustomComparator implements Comparator {

    public int compare(OpenVPNService.Profile p1, OpenVPNService.Profile p2) {
        return OpenVPNService.Profile.name.compareTo(OpenVPNService.Profile.name);
    }
}

class ConnectivityReceiver extends BroadcastReceiver {
    private final int ANTI_FLAP_PERIOD;
    public boolean conn_on;
    public boolean conn_on_defined;
    private boolean initialized;
    private long last_action_time;
    private boolean last_ok;
    public boolean screen_on;
    public boolean screen_on_defined;

    private ConnectivityReceiver(OpenVPNService p1) {
        ANTI_FLAP_PERIOD = 0x2710;
        screen_on_defined = false;
        screen_on = false;
        conn_on_defined = false;
        conn_on = false;
        last_ok = true;
        initialized = false;
    }

    public void onReceive(Context context, Intent intent) {
        boolean screen_on_mod = 0x0;
        boolean conn_on_mod = 0x0;
        boolean failover = 0x0;
        String act = intent.getAction();
        boolean pvbs = prefs.get_boolean("pause_vpn_on_blanked_screen", false);
        if ("android.intent.action.SCREEN_ON".equals(act)) {
            Log.i("OpenVPNService", String.format("ConnectivityReceiver: SCREEN_ON pvbs=%b", Boolean.valueOf(pvbs)));
            screen_on = true;
            screen_on_defined = screen_on_mod;
        } else if ("android.intent.action.SCREEN_OFF".equals(act)) {
            Log.i("OpenVPNService", String.format("ConnectivityReceiver: SCREEN_OFF pvbs=%b", Boolean.valueOf(pvbs), Boolean.valueOf(pvbs)));
            screen_on = false;
            screen_on_defined = screen_on_mod;
        } else if ("android.net.conn.CONNECTIVITY_CHANGE".equals(act)) {
            conn_on = (!intent.getBooleanExtra("noConnectivity", false));
            failover = intent.getBooleanExtra("isFailover", false);
            conn_on_defined = conn_on_mod;
            Log.i("OpenVPNService", String.format("ConnectivityReceiver: CONNECTIVITY_ACTION conn=%b fo=%b", Boolean.valueOf(pvbs), Boolean.valueOf(pvbs), Boolean.valueOf(conn_on), Boolean.valueOf(failover)));
        } else {
            Log.i("OpenVPNService", String.format("ConnectivityReceiver: UNKNOWN INTENT: %s", Boolean.valueOf(pvbs), Boolean.valueOf(pvbs), Boolean.valueOf(conn_on), Boolean.valueOf(failover), intent.toString()));
        }
        if ((screen_on_mod) || (conn_on_mod)) {
            boolean ok = !conn_on ? 0x1 : 0x0;
            (active)){
                if (ok != last_ok) {
                    if (ok) {
                        Log.i("OpenVPNService", "ConnectivityReceiver: triggering VPN resume");
                        network_resume();
                        last_ok = ok;
                    } else {
                        Log.i("OpenVPNService", "ConnectivityReceiver: triggering VPN pause");
                        network_pause();
                        last_ok = ok;
                    }else if ((screen_on_mod) && (screen_on) && (ok) && (!pvbs)) {
                        Log.i("OpenVPNService", "ConnectivityReceiver: triggering special VPN resume");
                        network_resume();
                    } else if ((conn_on_mod) && (failover) && (ok) && (initialized) && (time_since_last_action() > 0x2710)) {
                        Log.i("OpenVPNService", "ConnectivityReceiver: triggering VPN reconnect");
                        network_reconnect(0x2);
                    }
                }
            }
            if (conn_on_mod) {
                initialized = true;
                update_last_action_time();
            }
        }
    }

    private void update_last_action_time() {
        last_action_time = SystemClock.elapsedRealtime();
    }

    private long time_since_last_action() {
        return (SystemClock.elapsedRealtime() - last_action_time);
    }
}

    private void register_connectivity_receiver() {
        mConnectivityReceiver = new OpenVPNService.ConnectivityReceiver(this, 0x0);
        IntentFilter filter = new IntentFilter();
        filter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
        filter.addAction("android.intent.action.SCREEN_ON");
        filter.addAction("android.intent.action.SCREEN_OFF");
        registerReceiver(mConnectivityReceiver, filter);
    }

    private void unregister_connectivity_receiver() {
        unregisterReceiver(mConnectivityReceiver);
    }

    public void jellyBeanHackPurge() {
        if (jellyBeanHack != null) {
            jellyBeanHack.resetPrivateKey();
        }
    }

    private void crypto_self_test() {
        String st = ClientAPI_OpenVPNClient.crypto_self_test();
        if (st.length() > 0) {
            Log.d("OpenVPNService", String.format("SERV: crypto_self_test\n%s", st));
        }
    }

    public void onCreate() {
        super.onCreate();
        Log.d("OpenVPNService", "SERV: Service onCreate called");
        crypto_self_test();
        mHandler = new Handler(this);
        populate_event_info_map();
        register_connectivity_receiver();
        prefs = new PrefUtil(PreferenceManager.getDefaultSharedPreferences(this));
        pwds = new PasswordUtil(PreferenceManager.getDefaultSharedPreferences(this));
        jellyBeanHack = JellyBeanHack.newJellyBeanHack();
        proxy_list = new ProxyList(resString(0x7f0600cb));
        proxy_list.set_backing_file(this, "proxies.json");
        proxy_list.load();
    }

    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent != null) {
            String prefix = "net.openvpn.openvpn";
            String action = intent.getAction();
            Log.d("OpenVPNService", String.format("SERV: onStartCommand action=%s", action));
            if (action.equals("net.openvpn.openvpn.CONNECT")) {
                connect_action(prefix, intent, false);
                return 0x1;
            }
            if (action.equals("net.openvpn.openvpn.ACTION_SUBMIT_PROXY_CREDS")) {
                submit_proxy_creds_action(prefix, intent);
                return 0x1;
            }
            if (action.equals("net.openvpn.openvpn.DISCONNECT")) {
                disconnect_action(prefix, intent);
                return 0x1;
            }
            if (action.equals("net.openvpn.openvpn.IMPORT_PROFILE")) {
                import_profile_action(prefix, intent);
                return 0x1;
            }
            if (action.equals("net.openvpn.openvpn.ACTION_IMPORT_PROFILE_VIA_PATH")) {
                import_profile_via_path_action(prefix, intent);
                return 0x1;
            }
            if (action.equals("net.openvpn.openvpn.DELETE_PROFILE")) {
                delete_profile_action(prefix, intent);
                return 0x1;
            }
            if (action.equals("net.openvpn.openvpn.RENAME_PROFILE")) {
                rename_profile_action(prefix, intent);
            }
        }
        return 0x1;
    }

    private boolean import_profile_via_path_action(String prefix, Intent intent) {
        String path = intent.getStringExtra(prefix + ".PATH");
        ClientAPI_MergeConfig mc = ClientAPI_OpenVPNClient.merge_config_static(path, true);
        String status = "PROFILE_" + mc.getStatus();
        if (status.equals("PROFILE_MERGE_SUCCESS")) {
            return import_profile(mc.getProfileContent(), mc.getBasename(), false);
        }
        gen_event(0x1, status, mc.getErrorText());
        return false;
    }

    private boolean import_profile_action(String prefix, Intent intent) {
        String profile_content = intent.getStringExtra(prefix + ".CONTENT");
        String filename = intent.getStringExtra(prefix + ".FILENAME");
        boolean merge = intent.getBooleanExtra(prefix + ".MERGE", false);
        return import_profile(profile_content, filename, merge);
    }

    private boolean import_profile(String profile_content, String filename, boolean merge) {
        if ((!OpenVPNService.ProfileFN.has_ovpn_ext(filename)) || (FileUtil.dirname(filename) != null)) {
            gen_event(0x1, "PROFILE_FILENAME_ERROR", filename);
            return false;
        }
        if (merge) {
            ClientAPI_MergeConfig mc = ClientAPI_OpenVPNClient.merge_config_string_static(profile_content);
            String status = "PROFILE_" + mc.getStatus();
            if (!status.equals("PROFILE_MERGE_SUCCESS")) {
                gen_event(0x1, status, mc.getErrorText());
                return false;
            }
            profile_content = mc.getProfileContent();
        }
        ClientAPI_Config config = new ClientAPI_Config();
        config.setContent(profile_content);
        ClientAPI_EvalConfig ec = ClientAPI_OpenVPNClient.eval_config_static(config);
        if (ec.getError()) {
            gen_event(0x1, "PROFILE_PARSE_ERROR", String.format("%s : %s", filename, ec.getMessage()));
            return false;
        }
        OpenVPNService.Profile prof = new OpenVPNService.Profile(this, "imported", filename, false, ec, 0x0);
        try {
            FileUtil.writeFileAppPrivate(this, prof.get_filename(), profile_content);
        } catch (IOException e) {
            gen_event(0x1, "PROFILE_WRITE_ERROR", filename);
            return false;
        }
        String profile_name = prof.get_name();
        pwds.remove("auth", profile_name);
        pwds.remove("pk", profile_name);
        refresh_profile_list();
        gen_event(0x0, "PROFILE_IMPORT_SUCCESS", profile_name, profile_name);
        return true;
    }

    private boolean delete_profile_action(String prefix, Intent intent) {
        String profile_name = intent.getStringExtra(prefix + ".PROFILE");
        get_profile_list();
        OpenVPNService.Profile profile = profile_list.get_profile_by_name(profile_name);
        if (profile == null) {
            return false;
        }
        if (!profile.is_deleteable()) {
            gen_event(0x1, "PROFILE_DELETE_FAILED", profile_name);
            return false;
        }
        if ((active) && (profile == current_profile)) {
            stop_thread();
        }
        String filename = profile.get_filename();
        if (!deleteFile(filename)) {
            gen_event(0x1, "PROFILE_DELETE_FAILED", profile.get_name());
            return false;
        }
        pwds.remove("auth", profile_name);
        pwds.remove("pk", profile_name);
        refresh_profile_list();
        gen_event(0x0, "PROFILE_DELETE_SUCCESS", profile.get_name());
        return true;
        return true;
    }

    private boolean rename_profile_action(String prefix, Intent intent) {
        String profile_name = intent.getStringExtra(prefix + ".PROFILE");
        String new_profile_name = intent.getStringExtra(prefix + ".NEW_PROFILE");
        get_profile_list();
        OpenVPNService.Profile profile = profile_list.get_profile_by_name(profile_name);
        if (profile == null) {
            return false;
        }
        if ((!profile.is_renameable()) || (new_profile_name == null) || (new_profile_name.length() == 0)) {
            Log.d("OpenVPNService", "PROFILE_RENAME_FAILED: rename preliminary checks");
            gen_event(0x1, "PROFILE_RENAME_FAILED", profile_name);
            return false;
        }
        File dir = getFilesDir();
        String from_path = String.format("%s/%s", dir.getPath(), profile.orig_filename);
        String to_path = String.format("%s/%s", dir.getPath(), profile.orig_filename, dir.getPath(), OpenVPNService.ProfileFN.encode_profile_fn(new_profile_name));
        if (!FileUtil.renameFile(from_path, to_path)) {
            Log.d("OpenVPNService", String.format("PROFILE_RENAME_FAILED: rename operation from=\'%s\' to=\'%s\'", dir.getPath(), profile.orig_filename, dir.getPath(), OpenVPNService.ProfileFN.encode_profile_fn(new_profile_name), from_path, to_path));
            gen_event(0x1, "PROFILE_RENAME_FAILED", profile_name);
            return false;
        }
        refresh_profile_list();
        OpenVPNService.Profile new_profile = profile_list.get_profile_by_name(new_profile_name);
        if (new_profile == null) {
            Log.d("OpenVPNService", "PROFILE_RENAME_FAILED: post-rename profile get");
            gen_event(0x1, "PROFILE_RENAME_FAILED", profile_name);
            return false;
        }
        pwds.remove("auth", profile_name);
        pwds.remove("pk", profile_name);
        gen_event(0x0, "PROFILE_RENAME_SUCCESS", new_profile.get_name(), new_profile.get_name());
        return true;
        return true;
    }

    private OpenVPNService.Profile locate_profile(String profile_name) {
        get_profile_list();
        OpenVPNService.Profile profile = profile_list.get_profile_by_name(profile_name);
        if (profile == null) {
            gen_event(0x1, "PROFILE_NOT_FOUND", profile_name);
            return profile;
        }
        return profile;
    }

    private boolean submit_proxy_creds_action(String prefix, Intent intent) {
        String profile_name = intent.getStringExtra(prefix + ".PROFILE");
        OpenVPNService.Profile profile = locate_profile(profile_name);
        if (profile != null) {
            OpenVPNService.ProxyContext proxy_context = profile.get_proxy_context(false);
            if (proxy_context != null) {
                String proxy_name = intent.getStringExtra(prefix + ".PROXY_NAME");
                String username = intent.getStringExtra(prefix + ".PROXY_USERNAME");
                String password = intent.getStringExtra(prefix + ".PROXY_PASSWORD");
                boolean remember_creds = intent.getBooleanExtra(prefix + ".PROXY_REMEMBER_CREDS", false);
                Intent connect_intent = proxy_context.submit_proxy_creds(this, username, this, remember_creds, this);
                if (connect_intent != null) {
                    connect_action(prefix, connect_intent, true);
                    return true;
                }
            }
        }
        gen_event(0x1, "PROXY_CONTEXT_EXPIRED", 0x0);
        return false;
        return false;
    }

    private boolean connect_action(String prefix, Intent intent, boolean proxy_retry) {
        if (active) {
            stop_thread();
            int disconnect_reconnect_delay = 0x7d0;
            Handler handler = new Handler();
            OpenVPNService .1 task = new Runnable(this, prefix, intent, proxy_retry) {

                public void run() {
                }
            };
            handler.postDelayed(task, 0x7d0);
        } else {
            do_connect_action(prefix, intent, proxy_retry);
        }
        return true;
    }

    private boolean do_connect_action(String prefix, Intent intent, boolean proxy_retry) {
        String profile_name = intent.getStringExtra(prefix + ".PROFILE");
        String gui_version = intent.getStringExtra(prefix + ".GUI_VERSION");
        String proxy_name = intent.getStringExtra(prefix + ".PROXY_NAME");
        String proxy_username = intent.getStringExtra(prefix + ".PROXY_USERNAME");
        String proxy_password = intent.getStringExtra(prefix + ".PROXY_PASSWORD");
        boolean proxy_allow_creds_dialog = intent.getBooleanExtra(prefix + ".PROXY_ALLOW_CREDS_DIALOG", false);
        String server = intent.getStringExtra(prefix + ".SERVER");
        String proto = intent.getStringExtra(prefix + ".PROTO");
        String conn_timeout = intent.getStringExtra(prefix + ".CONN_TIMEOUT");
        String username = intent.getStringExtra(prefix + ".USERNAME");
        String password = intent.getStringExtra(prefix + ".PASSWORD");
        boolean cache_password = intent.getBooleanExtra(prefix + ".CACHE_PASSWORD", false);
        String pk_password = intent.getStringExtra(prefix + ".PK_PASSWORD");
        String response = intent.getStringExtra(prefix + ".RESPONSE");
        String epki_alias = intent.getStringExtra(prefix + ".EPKI_ALIAS");
        String compression_mode = intent.getStringExtra(prefix + ".COMPRESSION_MODE");
        password = OpenVPNDebug.pw_repl(username, password);
        OpenVPNService.Profile profile = locate_profile(profile_name);
        if (profile == null) {
            return false;
        }
        if (proxy_name != null) {
            OpenVPNService.ProxyContext proxy_context = profile.get_proxy_context(true);
            proxy_context.new_connection(intent, this, this, this, this, this, this, this);
        } else {
            int proxy_context = 0x0;
            profile.reset_proxy_context();
        }
        String location = profile.get_location();
        String filename = profile.get_filename();
        try {
            String profile_content = read_file(location, filename);
        } catch (IOException e) {
            gen_event(0x1, "PROFILE_NOT_FOUND", String.format("%s/%s", location, filename));
            return false;
        }
        Log.d("OpenVPNService", String.format("SERV: profile file len=%d", location, filename, profile_content.length());
        return start_connection(this, this, gui_version, this, server, this, conn_timeout, username, this, cache_password, this, response, epki_alias, compression_mode);
    }

    private void disconnect_action(String prefix, Intent intent) {
        boolean stop = intent.getBooleanExtra(prefix + ".STOP", false);
        stop_thread();
        if (stop) {
            stopSelf();
        }
    }

    private boolean start_connection(OpenVPNService.Profile profile, String profile_content, String gui_version, OpenVPNService.ProxyContext proxy_context, String server, String proto, String conn_timeout, String username, String password, boolean cache_password, String pk_password, String response, String epki_alias, String compression_mode) {
        if (active) {
            return false;
        }
        enable_notifications = prefs.get_boolean("enable_notifications", false);
        OpenVPNClientThread thread = new OpenVPNClientThread();
        ClientAPI_Config config = new ClientAPI_Config();
        config.setContent(profile_content);
        if (server != null) {
            config.setServerOverride(server);
        }
        if (proto != null) {
            config.setProtoOverride(proto);
        }
        if (conn_timeout != null) {
            int ct = 0x0;
            try {
                ct = Integer.parseInt(conn_timeout);
            } catch (NumberFormatException localNumberFormatException1) {
            }
            config.setConnTimeout(ct);
        }
        if (compression_mode != null) {
            config.setCompressionMode(compression_mode);
        }
        if (pk_password != null) {
            config.setPrivateKeyPassword(pk_password);
        }
        boolean tun_persist = prefs.get_boolean("tun_persist", false);
        if ((tun_persist) && (Build.VERSION.SDK_INT == 0x13)) {
            Log.i("OpenVPNService", "Seamless Tunnel disabled for KitKat 4.4 - 4.4.2");
            tun_persist = true;
        }
        config.setTunPersist(tun_persist);
        config.setGoogleDnsFallback(prefs.get_boolean("google_dns_fallback", false));
        config.setForceAesCbcCiphersuites(prefs.get_boolean("force_aes_cbc_ciphersuites_v2", false));
        config.setAltProxy(prefs.get_boolean("alt_proxy", false));
        String tls_version_min_override = prefs.get_string("tls_version_min_override");
        if (tls_version_min_override != null) {
            config.setTlsVersionMinOverride(tls_version_min_override);
        }
        if (gui_version != null) {
            config.setGuiVersion(gui_version);
        }
        if (localNumberFormatException1) {
            if (epki_alias != null) {
                OpenVPNService.Profile.persist_epki_alias(profile, epki_alias);
            } else {
                epki_alias =;
            }
            if (epki_alias != null) {
                if (epki_alias.equals("DISABLE_CLIENT_CERT")) {
                    config.setDisableClientCert(true);
                } else {
                    config.setExternalPkiAlias(epki_alias);
                }
            }
        }
        if (proxy_context != null) {
            proxy_context.client_api_config(config);
        }
        ClientAPI_EvalConfig ec = thread.eval_config(config);
        if (ec.getError()) {
            gen_event(0x1, "CONFIG_FILE_PARSE_ERROR", ec.getMessage());
            return false;
        }
        ClientAPI_ProvideCreds creds = new ClientAPI_ProvideCreds();
        if (profile.is_dynamic_challenge()) {
            if (response != null) {
                creds.setResponse(response);
            }
            creds.setDynamicChallengeCookie(OpenVPNService.Profile.dynamic_challenge.cookie);
            profile.reset_dynamic_challenge();
        } else if ((!ec.getAutologin()) && (username != null) && (username.length() == 0)) {
            gen_event(0x1, "NEED_CREDS_ERROR", 0x0);
            return false;
        }
        if (username != null) {
            creds.setUsername(username);
        } else if (password != null) {
            creds.setPassword(password);
        } else if (response != null) {
            creds.setResponse(response);
        }
        creds.setCachePassword(cache_password);
        creds.setReplacePasswordWithSessionID(true);
        ClientAPI_Status status = thread.provide_creds(creds);
        if (status.getError()) {
            gen_event(0x1, "CREDS_ERROR", status.getMessage());
            return false;
        }
        Log.i("OpenVPNService", String.format("SERV: CONNECT prof=%s user=%s proxy=%s serv=%s proto=%s to=%s resp=%s epki_alias=%s comp=%s", OpenVPNService.Profile.name, username, "undef", server, proto, conn_timeout, response, epki_alias, compression_mode));
        current_profile = profile;
        set_autostart_profile_name(profile.get_name());
        start_notification();
        gen_event(0x0, "CORE_THREAD_ACTIVE", 0x0);
        thread.connect(this);
        mThread = thread;
        thread_started = SystemClock.elapsedRealtime();
        cpu_usage = new CPUUsage();
        active = true;
        return true;
    }

    private void start_notification() {
        if ((mNotifyBuilder == null) && (current_profile != null)) {
            mNotifyBuilder = new Notification.Builder(this).setContentIntent(get_configure_intent(0x1)).setSmallIcon(0x7f020008).setContentTitle(current_profile.get_name()).setContentText(resString(0x7f0600ae)).setOnlyAlertOnce(true).setOngoing(true).setWhen(new Date().getTime());
            startForeground(0x66a, mNotifyBuilder.getNotification());
        }
    }

    private void update_notification_event(OpenVPNService.EventMsg evm) {
        if (mNotifyBuilder != null) {
            if (evm.priority >= 0x1) {
                switch (evm.icon_res_id) {
                    case 2130837505: {
                        mNotifyBuilder.setSmallIcon(0x7f02000c);
                    }
                    case 2130837504: {
                        mNotifyBuilder.setSmallIcon(0x7f02000b);
                    }
                    case 2130837509: {
                        mNotifyBuilder.setSmallIcon(0x7f02000d);
                    }
                    case 2130837506:
                    case 2130837507:
                    case 2130837508: {
                        mNotifyBuilder.setSmallIcon(0x7f020008);
                        mNotifyBuilder.setContentText(resString(evm.res_id));
                        startForeground(0x66a, mNotifyBuilder.getNotification());
                    }
                }
                break;
            }
        }
    }

    private void stop_notification() {
        if (mNotifyBuilder != null) {
            mNotifyBuilder = 0x0;
            stopForeground(true);
        }
    }

    public IBinder onBind(Intent intent) {
        if ((intent != null) && (intent.getAction().equals("net.openvpn.openvpn.BIND"))) {
            Log.d("OpenVPNService", String.format("SERV: onBind intent=%s", intent));
            return mBinder;
        }
        Log.d("OpenVPNService", String.format("SERV: onBind SUPER intent=%s", intent, intent));
        return super.onBind(intent);
    }

    public void client_attach(OpenVPNService.EventReceiver evr) {
        clients.remove(evr);
        clients.addFirst(evr);
        Log.d("OpenVPNService", String.format("SERV: client attach n_clients=%d", clients.size());
    }

    public void client_detach(OpenVPNService.EventReceiver evr) {
        clients.remove(evr);
        Log.d("OpenVPNService", String.format("SERV: client detach n_clients=%d", clients.size());
    }

    public void refresh_profile_list() {
        // :( Parsing error. Please contact me.
    }

    public OpenVPNService.Profile get_current_profile() {
        if (current_profile != null) {
            return current_profile;
        }
        OpenVPNService.ProfileList pl = get_profile_list();
        if (pl.size() >= 0x1) {
            return (OpenVPNService.Profile) pl.get(0x0);
        }
        return null;
    }

    public OpenVPNService.ProfileList get_profile_list() {
        if (profile_list == null) {
            refresh_profile_list();
        }
        return profile_list;
    }

    public static long max_profile_size() {
        return (long) ClientAPI_OpenVPNClient.max_profile_size();
    }

    public OpenVPNService.MergedProfile merge_parse_profile(String basename, String profile_content) {
        if ((basename != null) && (profile_content != null)) {
            ClientAPI_MergeConfig mc = ClientAPI_OpenVPNClient.merge_config_string_static(profile_content);
            String status = "PROFILE_" + mc.getStatus();
            if (status.equals("PROFILE_MERGE_SUCCESS")) {
                String merged_content = mc.getProfileContent();
                ClientAPI_Config config = new ClientAPI_Config();
                config.setContent(merged_content);
                ClientAPI_EvalConfig ec = ClientAPI_OpenVPNClient.eval_config_static(config);
                OpenVPNService.MergedProfile mp = new OpenVPNService.MergedProfile(this, "imported", basename, false, ec, 0x0);
                mp.profile_content = merged_content;
                return mp;
            }
            ClientAPI_EvalConfig ec = new ClientAPI_EvalConfig();
            OpenVPNService.EventInfo evi = (OpenVPNService.EventInfo) event_info.get(status);
            if (evi != null) {
                status = resString(evi.res_id);
            }
            ec.setError(true);
            ec.setMessage(status + " : " + mc.getErrorText());
            return new OpenVPNService.MergedProfile(this, "imported", basename, false, ec, 0x0);
        }
        return null;
    }

    public void gen_ui_reset_event(boolean exclude_self, OpenVPNService.EventReceiver cli) {
        int flags = 0x0;
        if (exclude_self) {
        }
        gen_event(flags, "UI_RESET", 0x0, 0x0, cli);
    }

    public void gen_proxy_context_expired_event() {
        gen_event(0x0, "PROXY_CONTEXT_EXPIRED", 0x0);
    }

    public boolean is_active() {
        return active;
    }

    public OpenVPNService.EventMsg get_last_event() {
        if ((last_event != null) && (!last_event.is_expired())) {
            return last_event;
        }
        return null;
    }

    public OpenVPNService.EventMsg get_last_event_prof_manage() {
        if ((last_event_prof_manage != null) && (!last_event_prof_manage.is_expired())) {
            return last_event_prof_manage;
        }
        return null;
    }

    public void network_pause() {
        if (active) {
            mThread.pause("");
        }
    }

    public void network_resume() {
        if (active) {
            mThread.resume();
        }
    }

    public void network_reconnect(int seconds) {
        if (active) {
            mThread.reconnect(seconds);
        }
    }

    public OpenVPNService.ConnectionStats get_connection_stats() {
        OpenVPNService.ConnectionStats cs = new OpenVPNService.ConnectionStats();
        ClientAPI_TransportStats stats = mThread.transport_stats();
        cs.last_packet_received = -0x1;
        if (active) {
            cs.duration = ((int) (SystemClock.elapsedRealtime() - thread_started) / 0x3e8);
            if (cs.duration < 0) {
                cs.duration = 0x0;
            }
            cs.bytes_in = stats.getBytesIn();
            cs.bytes_out = stats.getBytesOut();
            int lpr_bms = stats.getLastPacketReceived();
            if (lpr_bms >= 0) {
                cs.last_packet_received = (lpr_bms >> 0xa);
                return cs;
            }
        }
        cs.duration = 0x0;
        cs.bytes_in = 0x0;
        cs.bytes_out = 0x0;
        return cs;
    }

    public long get_tunnel_bytes_per_cpu_second() {
        if (cpu_usage != null) {
            double cpu_seconds = cpu_usage.usage();
            if (cpu_seconds > 0.0) {
                ClientAPI_InterfaceStats stats = mThread.tun_stats();
                long net_bytes = stats.getBytesIn() + stats.getBytesOut();
                double ret = (double) net_bytes / cpu_seconds;
                return (long) ret;
            }
        }
        return 0x0;
    }

    private PendingIntent get_configure_intent(int requestCode) {
        for (OpenVPNService.EventReceiver er : clients) {
            PendingIntent pi = er.get_configure_intent(requestCode);
            if (pi != null) {
                return pi;
            }
        }
        return null;
    }

    private void stop_thread() {
        if (active) {
            mThread.stop();
            mThread.wait_thread_short();
            Log.d("OpenVPNService", "SERV: stop_thread succeeded");
        }
    }

    public boolean onUnbind(Intent intent) {
        Log.d("OpenVPNService", String.format("SERV: onUnbind called intent=%s", intent.toString()));
        return super.onUnbind(intent);
    }

    public void onDestroy() {
        Log.d("OpenVPNService", "SERV: onDestroy called");
        shutdown_pending = true;
        stop_thread();
        unregister_connectivity_receiver();
        super.onDestroy();
    }

    public void onRevoke() {
        Log.d("OpenVPNService", "SERV: onRevoke called");
        stop_thread();
    }

    private void gen_event(int flags, String name, String extra_info) {
        gen_event(flags, name, extra_info, 0x0, 0x0);
    }

    private void gen_event(int flags, String name, String extra_info, String profile_override) {
        gen_event(flags, name, extra_info, this, 0x0);
    }

    private void gen_event(int flags, String name, String extra_info, String profile_override, OpenVPNService.EventReceiver sender) {
        OpenVPNService.EventInfo evi = (OpenVPNService.EventInfo) event_info.get(name);
        OpenVPNService.EventMsg evm = new OpenVPNService.EventMsg();
        evm.flags = event_info;
        if (evi != null) {
            evm.progress = evi.progress;
            evm.priority = evi.priority;
            evm.res_id = evi.res_id;
            evm.icon_res_id = evi.icon_res_id;
            evm.sender = sender;
            evm.flags = (evm.flags | evi.flags);
        } else {
            evm.res_id = 0x7f060042;
        }
        evm.name = name;
        if (extra_info != null) {
            evm.info = extra_info;
        } else {
            evm.info = "";
        }
        if ((evm.flags & 0x4) != 0) {
            evm.expires = (SystemClock.elapsedRealtime() + 0xea60);
        }
        evm.profile_override = profile_override;
        Message msg = mHandler.obtainMessage(0x1, evm);
        mHandler.sendMessage(msg);
    }

    public boolean handleMessage(Message msg) {
        // :( Parsing error. Please contact me.
    }

    private void log_message(String line) {
        OpenVPNService.LogMsg lm = new OpenVPNService.LogMsg();
        lm.line = line + "\n";
        log_message(lm);
    }

    private void log_message(OpenVPNService.LogMsg lm) {
        lm.line = String.format("%s -- %s", dateFormat.format(new Date()), lm.line);
        log_deque.addLast(lm);
        while (log_deque.size() > 0xfa) {
            log_deque.removeFirst();
        }
        for (OpenVPNService.EventReceiver cli : clients) {
            cli.log(lm);
        }
    }

    public boolean socket_protect(int socket) {
        boolean status = protect(socket);
        Log.d("OpenVPNService", String.format("SOCKET PROTECT: fd=%d protected status=%b", socket, Boolean.valueOf(status)));
        return status;
    }

    public boolean pause_on_connection_timeout() {
        boolean ret = 0x0;
        if (mConnectivityReceiver != null) {
            if ((mConnectivityReceiver.screen_on_defined) && (!mConnectivityReceiver.screen_on)) {
                ret = true;
            }
        }
        Log.d("OpenVPNService", String.format("pause_on_connection_timeout %b", Boolean.valueOf(ret)));
        return ret;
    }

    public OpenVPNClientThread.TunBuilder tun_builder_new() {
        return new OpenVPNService.TunBuilder(this, 0x0);
    }

    public void event(ClientAPI_Event event) {
        OpenVPNService.EventMsg evm = new OpenVPNService.EventMsg();
        if (event.getError()) {
            evm.flags = evm.flags;
        }
        evm.name = event.getName();
        evm.info = event.getInfo();
        OpenVPNService.EventInfo evi = (OpenVPNService.EventInfo) event_info.get(evm.name);
        if (evi != null) {
            evm.progress = evi.progress;
            evm.priority = evi.priority;
            evm.res_id = evi.res_id;
            evm.icon_res_id = evi.icon_res_id;
            evm.flags = (evm.flags | evi.flags);
            if ((evi.res_id == 0x7f060019) && (mThread != null)) {
                evm.conn_info = mThread.connection_info();
            }
        } else {
            evm.res_id = 0x7f060042;
        }
        Message msg = mHandler.obtainMessage(0x1, evm);
        mHandler.sendMessage(msg);
    }

    public void log(ClientAPI_LogInfo loginfo) {
        OpenVPNService.LogMsg lm = new OpenVPNService.LogMsg();
        lm.line = loginfo.getText();
        Message msg = mHandler.obtainMessage(0x2, lm);
        mHandler.sendMessage(msg);
    }

    private String cert_format_pem(X509Certificate cert) throws CertificateEncodingException {
        byte[] cert_bytes = cert.getEncoded();
        return String.format("-----BEGIN CERTIFICATE-----%n%s-----END CERTIFICATE-----%n", Base64.encodeToString(cert_bytes, 0x0));
    }

    public void external_pki_cert_request(ClientAPI_ExternalPKICertRequest req) {
        // :( Parsing error. Please contact me.
    }

    public void external_pki_sign_request(ClientAPI_ExternalPKISignRequest req) {
        // :( Parsing error. Please contact me.
    }

    public void done(ClientAPI_Status status) {
        boolean err = status.getError();
        String msg = status.getMessage();
        Log.d("OpenVPNService", String.format("EXIT: connect() exited, err=%b, msg=\'%s\'", Boolean.valueOf(err), msg));
        log_stats();
        if (err) {
            if ((msg != null) && (msg.equals("CORE_THREAD_ABANDONED"))) {
                gen_event(0x1, "CORE_THREAD_ABANDONED", 0x0);
            } else {
                String label = status.getStatus();
                if (label.length() == 0) {
                    String label = "CORE_THREAD_ERROR";
                } else {
                    gen_event(0x1, label, msg);
                }
            }
        }
        gen_event(0x0, "CORE_THREAD_INACTIVE", 0x0);
        active = false;
    }

    public void set_autostart_profile_name(String profile_name) {
        if (profile_name != null) {
            prefs.set_string("autostart_profile_name", profile_name);
            return;
        }
        prefs.delete_key("autostart_profile_name");
    }

    public static String[] stat_names() {
        int size = ClientAPI_OpenVPNClient.stats_n();
        String[] ret = new String[size];
        for (int i = 0x0; i < size; i = i + 0x1) {
            ret[i] = ClientAPI_OpenVPNClient.stats_name(i);
        }
        return ret;
    }

    public ClientAPI_LLVector stat_values_full() {
        if (mThread != null) {
            return mThread.stats_bundle();
        }
        return null;
    }

    protected static Date get_app_expire() {
        int expire = ClientAPI_OpenVPNClient.app_expire();
        if (expire > 0) {
            return new Date(((long) expire * 0x3e8));
        }
        return null;
    }

    protected static String get_openvpn_core_platform() {
        return ClientAPI_OpenVPNClient.platform();
    }

    private void log_stats() {
        if (active) {
            String[] sn = stat_names();
            ClientAPI_LLVector sv = stat_values_full();
            if (sv != null) {
                for (int i = 0x0; i < sn.length; i = i + 0x1) {
                    String name = sn[i];
                    long value = sv.get(i);
                    if (value > 0x0) {
                        Log.i("OpenVPNService", String.format("STAT %s=%s", name, value));
                    }
                }
            }
        }
    }

    public String read_file(String location, String filename) throws IOException {
        if (location.equals("bundled")) {
            return FileUtil.readAsset(this, filename);
        }
        if (location.equals("imported")) {
            return FileUtil.readFileAppPrivate(this, filename);
        }
        throw new OpenVPNService.InternalError();
    }

    private String resString(int res_id) {
        return getResources().getString(res_id);
    }

    private void populate_event_info_map() {
        event_info = new HashMap();
        event_info.put("RECONNECTING", new OpenVPNService.EventInfo(0x7f060018, 0x7f020001, 0x14, 0x2, 0x0));
        event_info.put("RESOLVE", new OpenVPNService.EventInfo(0x7f06001d, 0x7f020001, 0x1e, 0x1, 0x0));
        event_info.put("WAIT_PROXY", new OpenVPNService.EventInfo(0x7f06001f, 0x7f020001, 0x28, 0x1, 0x0));
        event_info.put("WAIT", new OpenVPNService.EventInfo(0x7f06001e, 0x7f020001, 0x32, 0x1, 0x0));
        event_info.put("CONNECTING", new OpenVPNService.EventInfo(0x7f060017, 0x7f020001, 0x3c, 0x1, 0x0));
        event_info.put("GET_CONFIG", new OpenVPNService.EventInfo(0x7f060022, 0x7f020001, 0x46, 0x1, 0x0));
        event_info.put("ASSIGN_IP", new OpenVPNService.EventInfo(0x7f060023, 0x7f020001, 0x50, 0x1, 0x0));
        event_info.put("ADD_ROUTES", new OpenVPNService.EventInfo(0x7f060024, 0x7f020001, 0x5a, 0x1, 0x0));
        event_info.put("CONNECTED", new OpenVPNService.EventInfo(0x7f060019, 0x7f020000, 0x64, 0x3, 0x0));
        event_info.put("DISCONNECTED", new OpenVPNService.EventInfo(0x7f06001a, 0x7f020003, 0x0, 0x2, 0x0));
        event_info.put("AUTH_FAILED", new OpenVPNService.EventInfo(0x7f060027, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("PEM_PASSWORD_FAIL", new OpenVPNService.EventInfo(0x7f060028, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("CERT_VERIFY_FAIL", new OpenVPNService.EventInfo(0x7f060029, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("TLS_VERSION_MIN", new OpenVPNService.EventInfo(0x7f06002a, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("DYNAMIC_CHALLENGE", new OpenVPNService.EventInfo(0x7f06002b, 0x7f020005, 0x0, 0x2, 0x0));
        event_info.put("TUN_SETUP_FAILED", new OpenVPNService.EventInfo(0x7f06002c, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("TUN_IFACE_CREATE", new OpenVPNService.EventInfo(0x7f06002d, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("TAP_NOT_SUPPORTED", new OpenVPNService.EventInfo(0x7f06002e, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("PROFILE_NOT_FOUND", new OpenVPNService.EventInfo(0x7f06002f, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("CONFIG_FILE_PARSE_ERROR", new OpenVPNService.EventInfo(0x7f060034, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("NEED_CREDS_ERROR", new OpenVPNService.EventInfo(0x7f060035, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("CREDS_ERROR", new OpenVPNService.EventInfo(0x7f060036, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("CONNECTION_TIMEOUT", new OpenVPNService.EventInfo(0x7f06003d, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("INACTIVE_TIMEOUT", new OpenVPNService.EventInfo(0x7f06003e, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("PROXY_NEED_CREDS", new OpenVPNService.EventInfo(0x7f06003f, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("PROXY_ERROR", new OpenVPNService.EventInfo(0x7f060040, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("PROXY_CONTEXT_EXPIRED", new OpenVPNService.EventInfo(0x7f060041, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("EPKI_ERROR", new OpenVPNService.EventInfo(0x7f06003a, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("EPKI_INVALID_ALIAS", new OpenVPNService.EventInfo(0x7f06003b, 0x7f020005, 0x0, 0x0, 0x0));
        event_info.put("PAUSE", new OpenVPNService.EventInfo(0x7f06001b, 0x7f02000e, 0x0, 0x3, 0x0));
        event_info.put("RESUME", new OpenVPNService.EventInfo(0x7f06001c, 0x7f020001, 0x0, 0x2, 0x0));
        event_info.put("CORE_THREAD_ACTIVE", new OpenVPNService.EventInfo(0x7f060015, 0x7f020001, 0xa, 0x1, 0x0));
        event_info.put("CORE_THREAD_INACTIVE", new OpenVPNService.EventInfo(0x7f060016, -0x1, 0x0, 0x0, 0x0));
        event_info.put("CORE_THREAD_ERROR", new OpenVPNService.EventInfo(0x7f060037, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("CORE_THREAD_ABANDONED", new OpenVPNService.EventInfo(0x7f060038, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("CLIENT_HALT", new OpenVPNService.EventInfo(0x7f060025, 0x7f020005, 0x0, 0x3, 0x0));
        event_info.put("CLIENT_RESTART", new OpenVPNService.EventInfo(0x7f060026, 0x7f020001, 0x0, 0x2, 0x0));
        event_info.put("PROFILE_IMPORT_SUCCESS", new OpenVPNService.EventInfo(0x7f060081, 0x7f020011, 0x0, 0x2, 0x2c));
        event_info.put("PROFILE_DELETE_SUCCESS", new OpenVPNService.EventInfo(0x7f060082, 0x7f020002, 0x0, 0x2, 0xc));
        event_info.put("PROFILE_DELETE_FAILED", new OpenVPNService.EventInfo(0x7f060083, 0x7f020005, 0x0, 0x2, 0x4));
        event_info.put("PROFILE_PARSE_ERROR", new OpenVPNService.EventInfo(0x7f060030, 0x7f020005, 0x0, 0x3, 0x4));
        event_info.put("PROFILE_CONFLICT", new OpenVPNService.EventInfo(0x7f060031, 0x7f020005, 0x0, 0x3, 0x4));
        event_info.put("PROFILE_WRITE_ERROR", new OpenVPNService.EventInfo(0x7f060032, 0x7f020005, 0x0, 0x3, 0x4));
        event_info.put("PROFILE_FILENAME_ERROR", new OpenVPNService.EventInfo(0x7f060033, 0x7f020005, 0x0, 0x3, 0x4));
        event_info.put("PROFILE_RENAME_SUCCESS", new OpenVPNService.EventInfo(0x7f060084, 0x7f020011, 0x0, 0x2, 0xc));
        event_info.put("PROFILE_RENAME_FAILED", new OpenVPNService.EventInfo(0x7f060085, 0x7f020005, 0x0, 0x2, 0x4));
        event_info.put("PROFILE_MERGE_EXCEPTION", new OpenVPNService.EventInfo(0x7f060045, 0x7f020005, 0x0, 0x2, 0x4));
        event_info.put("PROFILE_MERGE_OVPN_EXT_FAIL", new OpenVPNService.EventInfo(0x7f060046, 0x7f020005, 0x0, 0x2, 0x4));
        event_info.put("PROFILE_MERGE_OVPN_FILE_FAIL", new OpenVPNService.EventInfo(0x7f060047, 0x7f020005, 0x0, 0x2, 0x4));
        event_info.put("PROFILE_MERGE_REF_FAIL", new OpenVPNService.EventInfo(0x7f060048, 0x7f020005, 0x0, 0x2, 0x4));
        event_info.put("PROFILE_MERGE_MULTIPLE_REF_FAIL", new OpenVPNService.EventInfo(0x7f060049, 0x7f020005, 0x0, 0x2, 0x4));
        event_info.put("UI_RESET", new OpenVPNService.EventInfo(0x7f06004a, 0x7f020011, 0x0, 0x0, 0x8));
    }

class TunBuilder extends VpnService.Builder implements OpenVPNClientThread.TunBuilder {

    public boolean tun_builder_set_remote_address(String address, boolean ipv6) {
        try {
            Log.d("OpenVPNService", String.format("BUILDER: set_remote_address %s ipv6=%b", address, Boolean.valueOf(ipv6)));
            return true;
        } catch (Exception e) {
            log_error("tun_builder_set_remote_address", e);
            return false;
        }
        return true;
    }

    public boolean tun_builder_add_address(String address, int prefix_length, String gateway, boolean ipv6, boolean net30) {
        try {
            Log.d("OpenVPNService", String.format("BUILDER: add_address %s/%d %s ipv6=%b net30=%b", address, prefix_length, gateway, Boolean.valueOf(ipv6), Boolean.valueOf(net30)));
            addAddress(address, prefix_length);
            return true;
        } catch (Exception e) {
            log_error("tun_builder_add_address", e);
            return false;
        }
        return true;
    }

    public boolean tun_builder_reroute_gw(boolean ipv4, boolean ipv6, long flags) {
        long EmulateExcludeRoutes = 0x1;
        try {
            Log.d("OpenVPNService", String.format("BUILDER: reroute_gw ipv4=%b ipv6=%b flags=%d", Boolean.valueOf(ipv4), Boolean.valueOf(ipv6), flags));
            if (0x1 == 0x0) {
                if (ipv4) {
                    addRoute("0.0.0.0", 0x0);
                }
                if (ipv6) {
                    addRoute("::", 0x0);
                    return true;
                }
            }catch(Exception e){
                log_error("tun_builder_add_route", e);
                return false;
            }

        }
        return true;
    }

    public boolean tun_builder_add_route(String address, int prefix_length, boolean ipv6) {
        try {
            Log.d("OpenVPNService", String.format("BUILDER: add_route %s/%d ipv6=%b", address, prefix_length, Boolean.valueOf(ipv6)));
            addRoute(address, prefix_length);
            return true;
        } catch (Exception e) {
            log_error("tun_builder_add_route", e);
            return false;
        }
        return true;
    }

    public boolean tun_builder_exclude_route(String address, int prefix_length, boolean ipv6) {
        try {
            Log.d("OpenVPNService", String.format("BUILDER: exclude_route %s/%d ipv6=%b (NOT IMPLEMENTED)", address, prefix_length, Boolean.valueOf(ipv6)));
            return true;
        } catch (Exception e) {
            log_error("tun_builder_exclude_route", e);
            return false;
        }
        return true;
    }

    public boolean tun_builder_add_dns_server(String address, boolean ipv6) {
        try {
            Log.d("OpenVPNService", String.format("BUILDER: add_dns_server %s ipv6=%b", address, Boolean.valueOf(ipv6)));
            addDnsServer(address);
            return true;
        } catch (Exception e) {
            log_error("tun_builder_add_dns_server", e);
            return false;
        }
        return true;
    }

    public boolean tun_builder_add_search_domain(String domain) {
        try {
            Log.d("OpenVPNService", String.format("BUILDER: add_search_domain %s", domain));
            addSearchDomain(domain);
            return true;
        } catch (Exception e) {
            log_error("tun_builder_add_search_domain", e);
            return false;
        }
        return true;
    }

    public boolean tun_builder_set_mtu(int mtu) {
        try {
            Log.d("OpenVPNService", String.format("BUILDER: set_mtu %d", mtu));
            setMtu(mtu);
            return true;
        } catch (Exception e) {
            log_error("tun_builder_set_mtu", e);
            return false;
        }
        return true;
    }

    public boolean tun_builder_set_session_name(String name) {
        try {
            Log.d("OpenVPNService", String.format("BUILDER: set_session_name %s", name));
            setSession(name);
            return true;
        } catch (Exception e) {
            log_error("tun_builder_set_session_name", e);
            return false;
        }
        return true;
    }

    public int tun_builder_establish() {
        try {
            Log.d("OpenVPNService", "BUILDER: establish");
            PendingIntent pi = ;
            if (pi != null) {
                setConfigureIntent(pi);
            }
            ParcelFileDescriptor pfd = establish();
            return pfd.detachFd();
        } catch (Exception e) {
            log_error("tun_builder_establish", e);
        }
        return -0x1;
    }

    public void tun_builder_teardown(boolean disconnect) {
        try {
            Log.d("OpenVPNService", String.format("BUILDER: teardown disconnect=%b", Boolean.valueOf(disconnect)));
            return;
        } catch (Exception e) {
            log_error("tun_builder_teardown", e);
        }
    }

    private void log_error(String meth_name, Exception e) {
        Log.d("OpenVPNService", String.format("BUILDER_ERROR: %s %s", meth_name, e.toString()));
    }
}
}
