/**
  * Generated by smali2java 1.0.0.558
  * Copyright (C) 2013 Hensence.com
  */

package net.openvpn.openvpn;

import java.text.SimpleDateFormat;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import java.io.IOException;
import java.text.ParseException;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.Reader;
import android.util.Base64;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import org.xmlpull.v1.XmlSerializer;
import java.util.Date;
import java.util.Calendar;
import java.util.Iterator;
import java.util.Set;

public class XMLRPC {
    public static final String DATETIME_FORMAT = "yyyyMMdd\'T\'HH:mm:ss";
    public static final String TAG_DATA = "data";
    public static final String TAG_MEMBER = "member";
    public static final String TAG_NAME = "name";
    public static final String TAG_VALUE = "value";
    public static final String TYPE_ARRAY = "array";
    public static final String TYPE_BASE64 = "base64";
    public static final String TYPE_BOOLEAN = "boolean";
    public static final String TYPE_DATE_TIME_ISO8601 = "dateTime.iso8601";
    public static final String TYPE_DOUBLE = "double";
    public static final String TYPE_I4 = "i4";
    public static final String TYPE_I8 = "i8";
    public static final String TYPE_INT = "int";
    public static final String TYPE_STRING = "string";
    public static final String TYPE_STRUCT = "struct";
    
    public XMLRPC() {
    }
    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd\'T\'HH:mm:ss");
    
    public static Object parse_response(XmlPullParser pullParser) throws XmlPullParserException, XMLRPC.XMLRPCException, IOException {
        nextTag();
        require(0x2, 0x0, "methodResponse");
        nextTag();
        String tag = getName();
        if(tag.equals("params")) {
            nextTag();
            require(0x2, 0x0, "param");
            nextTag();
            Object obj = deserialize(pullParser);
            return obj;
        }
        if(tag.equals("fault")) {
            nextTag();
            Map<String, Object> map = (Map)deserialize(pullParser);
            String faultString = (String)map.get("faultString");
            int faultCode = (Integer)map.get("faultCode").intValue();
            throw new XMLRPC.XMLRPCFault(faultString, faultCode);
        }
        throw new XMLRPC.XMLRPCException("Bad tag <" + tag + "> in XMLRPC response - neither <params> nor <fault>");
    }
    
    public static void serialize(XmlSerializer serializer, Object object) throws IOException {
        if((object instanceof Integer) || (object instanceof Short) || (object instanceof Byte)) {
            serializer.startTag(0x0, "i4").text(object.toString()).endTag(0x0, "i4");
            return;
        }
        if(object instanceof Long) {
            serializer.startTag(0x0, "i8").text(object.toString()).endTag(0x0, "i8");
            return;
        }
        if((object instanceof Double) || (object instanceof Float)) {
            serializer.startTag(0x0, "double").text(object.toString()).endTag(0x0, "double");
            return;
        }
        if(object instanceof Boolean) {
            Object bool = object;
            bool.booleanValue() ? "1" : ;
            serializer.startTag(0x0, "boolean").text(boolStr).endTag(0x0, "boolean");
            return;
        }
        if(object instanceof String) {
            serializer.startTag(0x0, "string").text(object.toString()).endTag(0x0, "string");
            return;
        }
        if((object instanceof Date) || (object instanceof Calendar)) {
            String dateStr = dateFormat.format(object);
            serializer.startTag(0x0, "dateTime.iso8601").text(dateStr).endTag(0x0, "dateTime.iso8601");
            return;
        }
        if(object instanceof byte[]) {
            String value = Base64.encodeToString(object, 0x2);
            serializer.startTag(0x0, "base64").text(value).endTag(0x0, "base64");
            return;
        }
        if(object instanceof List) {
            serializer.startTag(0x0, "array").startTag(0x0, "data");
            Object list = object;
            Iterator<Object> iter = list.iterator();
            while(iter.hasNext()) {
                Object o = iter.next();
                serializer.startTag(0x0, "value");
                serialize(serializer, o);
                serializer.endTag(0x0, "value");
            }
            serializer.endTag(0x0, "data").endTag(0x0, "array");
            return;
        }
        if(object instanceof Object[]) {
            serializer.startTag(0x0, "array").startTag(0x0, "data");
            Object[] objects = (Object[])object;
            for(int i = 0x0; i < objects.length; i = i + 0x1) {
                Object o = objects[i];
                serializer.startTag(0x0, "value");
                serialize(serializer, o);
                serializer.endTag(0x0, "value");
            }
            serializer.endTag(0x0, "data").endTag(0x0, "array");
            return;
        }
        if(object instanceof Map) {
            serializer.startTag(0x0, "struct");
            Object map = object;
            Iterator<Map.Entry<String, Object>> iter = localSet1.iterator();
            while(iter.hasNext()) {
                Map.Entry<String, Object> entry = (Map.Entry)iter.next();
                String key = (String)entry.getKey();
                Object value = entry.getValue();
                serializer.startTag(0x0, "member");
                serializer.startTag(0x0, "name").text(key).endTag(0x0, "name");
                serializer.startTag(0x0, "value");
                serialize(serializer, value);
                serializer.endTag(0x0, "value");
                serializer.endTag(0x0, "member");
            }
            serializer.endTag(0x0, "struct");
            return;
        }
        if(object instanceof XMLRPC.Serializable) {
            Object serializable = object;
            serialize(serializer, serializable.getSerializable());
            return;
        }
        throw new IOException("Cannot serialize " + object);
    }
    
    public static Object deserialize(XmlPullParser parser) throws XmlPullParserException, IOException {
        // :( Parsing error. Please contact me.
    }
}
